# Review ACStor test 

## Current implemetation 

- In general it is a command-line tool (`clap`) for doing end-to-end test. 
- By using different parameters , it construct a workload. So, each workload is executed precisely as different subcommands.
- At the start of workload, it get global settings from json file located in Azure files. This is global predefined settings.
- Then, it executes a serise of predefined workload steps. Each workload step is constructed as a variant of enum `Step` for: 
  - `Step` impl `pub async fn execute(&self, storage_service: &StorageManagerService) -> Result<StepResult>` to uniform step execution result. 
  - `Step` take a global `StorageManagerService` instance which implement different method to get different storage context.
    - So, `StorageManagerService` is a global service which could load context dynamically. Such as the current pods status.
  - `StepResult` is also a enum which implements multiple `impl TryFrom<StepResult> for xx` to use as 

    ```rust 
    let go_exe_file: String = Step::Cluster {
        step: ClusterStep::PrepareLatesGoTestExe,
    }
    .execute(storage_service)
    .await?
    .into()?;      
    ```
- Each workload is executed as a sequece of step execution. 
  - At the end of workload, it usually runs a common function to do some cleanup jobs.

## How ACStor handle changes 

- For new scenarios, we define different workload by adding different subcommands. 
- For modify existing workload, we could add/edit existing steps of workload. 
- For injecting different context, we could implement additional features on `StorageManagerService`.
- For different retry: 
  - it is defined in on each step's execution.
  - there is a retry for entire workload with `run_workload_with_retry` which simply delete all and run workload again.
- For auto-troubleshooting
  - Errors are define at different level. 
  - When workload is executing, the error it produces are `AcstorStorageError`. 
  - After that, it goes through patter matching with context from `StorageManagerService` to transform error into `WorkloadError`
  - At last, it generate report based on `WorkloadError`.

## How it ends up like this 

- First version
  - It is aim to build a command-line tool such that the developer could run E2E tests by their own or in their DevOps pipeline.
  - So, simply clap + enum solved that problem. 
  - A workload is just a sequence of pure functions. 
- Second change 
  - It would be better we could run a single test step with context. 
  - This change introduces `StorageManagerService` and make each function becomes a `Step` which is a clap `Subcommand`.
- Third change
  - It is would be better to get the result of each step execution directly instead of checking them from `StorageManagerService`.
  - So, each step execution now return `StepResult` instead of `()`.
- Fourth change
  - It would be better to do some auto-triage and based its result do further actions, like retry entire workload. 
  - This change force us to use enum to group all errors. 
  - Auto-triage is done by checking step records from `StorageManagerService` + error.

## Note on longhaul test 

- The is a requirement for doing longhaul test for large scale fio test. 
- Currently it is implement as a manager-workers using ractor. 
  - Manager spawn multiple workers.
  - Multiple workers run on dozens of independent fio workload test and report result to manager.
- The longhaul part is not idea due to our ACStor execution platform's limitition.



## Current ACStor limititions 

- The workload execution are predefined. Most execution are hardcoded wihtout dynamic changes base on current execution situation.
- Therefore, it is hard to do randomly test or rule based test. 
- Longhaul testing is somehow specialy different from other workload test.


## Improve: Workload as state machine 

- Implement workload as state-machine such that it handle events from different sources. 
- Events could be generated by some planner or generated from its own state change. 
- Just like server implementation for tcp or udp connection.
- This enables:
  - random or dynamic workload test 
  - retry and error triage becomes event driven in workload